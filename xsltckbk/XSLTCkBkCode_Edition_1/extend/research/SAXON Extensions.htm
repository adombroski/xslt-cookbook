<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0055)http://saxon.sourceforge.net/saxon6.5.1/extensions.html -->
<HTML><HEAD><TITLE>SAXON Extensions</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<STYLE type=text/css>H1 {
	FONT-WEIGHT: bold; FONT-SIZE: 16pt; COLOR: #ff0080; FONT-FAMILY: Arial, Helvetica, sans-serif
}
H2 {
	FONT-WEIGHT: bold; FONT-SIZE: 14pt; COLOR: #ff0080; FONT-FAMILY: Arial, Helvetica, sans-serif
}
H3 {
	FONT-WEIGHT: bold; FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: Arial, Helvetica, sans-serif
}
P {
	FONT-WEIGHT: normal; FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Arial, Helvetica, sans-serif
}
LI {
	FONT-WEIGHT: normal; FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Arial, Helvetica, sans-serif
}
TD {
	FONT-WEIGHT: normal; FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Arial, Helvetica, sans-serif
}
CODE {
	FONT-WEIGHT: normal; FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: Courier, monospace
}
</STYLE>

<META content="MSHTML 6.00.2719.2200" name=GENERATOR></HEAD>
<BODY bgColor=#ddeeff leftMargin=150><FONT face="Arial, Helvetica, sans-serif">
<DIV align=right><A 
href="http://saxon.sourceforge.net/saxon6.5.1/index.html">SAXON home 
page</A></DIV><B><FONT face="Arial, Helvetica, sans-serif" size=4>
<H1><BIG>SAXON Extensions</BIG></H1>
<P>This page describes the extension functions and extension elements supplied 
with the SAXON product.</P>
<P>If you want to implement your own extensions, see <A 
href="http://saxon.sourceforge.net/saxon6.5.1/extensibility.html">extensibility.html</A>.</P>
<P>These extension functions and elements have been provided because there are 
things that are difficult to achieve, or inefficient, using standard XSLT 
facilities alone. As always, it is best to stick to standard if you possibly 
can: and most things <I>are</I> possible, even if it's not obvious at first 
sight.</P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=middle bgColor=#ffff00><B>Before using a Saxon extension, check 
      whether there is an equivalent <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#EXSLT">EXSLT</A> 
      extension available. EXSLT extensions are more likely to be portable 
      across XSLT processors. </B></TD></TR></TBODY></TABLE>
<P>&nbsp;</P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD bgColor=#0000ff colSpan=3><FONT 
      color=#ffffff><BIG><B>Contents</B></BIG></FONT></TD></TR>
  <TR>
    <TD vAlign=top width="33%" bgColor=#00ffff><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#extension attributes"><B>Extension 
      attributes</B></A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#trace">saxon:trace</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#allow-avt">saxon:allow-avt</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#disable">saxon:disable-output-escaping</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#output">additional 
      xsl:output and xsl:document attributes</A> </TD>
    <TD vAlign=top width="33%" bgColor=#00ffff><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#extension functions"><B>Extension 
      functions</B></A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#after">saxon:after()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#before">saxon:before()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#closure">saxon:closure()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#difference">saxon:difference()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#distinct">saxon:distinct()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#evaluate">saxon:evaluate()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#exists">saxon:exists()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#forall">saxon:forAll()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#getpseudoattribute">saxon:getPseudoAttribute()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#getuserdata">saxon:getUserData()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#hassamenodes">saxon:hasSameNodes()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#highest">saxon:highest()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#if">saxon:if()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#ifnull">saxon:ifNull()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#intersection">saxon:intersection()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#leading">saxon:leading()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#linenumber">saxon:lineNumber()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#lowest">saxon:lowest()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#max">saxon:max()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#min">saxon:min()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#nodeset">saxon:nodeSet()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#path">saxon:path()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#range">saxon:range()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#setuserdata">saxon:setUserData()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#sum">saxon:sum()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#systemid">saxon:systemId()</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#tokenize">saxon:tokenize()</A><BR></TD>
    <TD vAlign=top bgColor=#00ffff><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#extension elements"><B>Extension 
      elements</B></A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:assign">saxon:assign</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:doctype">saxon:doctype</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:entity-ref">saxon:entity-ref</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:function">saxon:function</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:group">saxon:group</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:handler">saxon:handler</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:item">saxon:item</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:output">saxon:output</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:preview">saxon:preview</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:return">saxon:return</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:script">saxon:script</A><BR><A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:while">saxon:while</A><BR></TD></TR></TBODY></TABLE>
<H3><A name=EXSLT>EXSLT</A></H3>
<P><A href="http://www.exslt.org/">EXSLT</A> is an initiative to define a 
standardized set of extension functions and extension elements that can be used 
across different XSLT processors.</P>
<P>Saxon now supports the EXSLT modules Common, Math, Sets, DatesAndTimes, and 
Functions. The full list of EXSLT extension functions implemented is:</P>
<UL>
  <LI>exslt:node-set() 
  <LI>exslt:object-type() 
  <LI>math:min() 
  <LI>math:max() 
  <LI>math:highest() 
  <LI>math:lowest() 
  <LI>set:difference() 
  <LI>set:intersection() 
  <LI>set:distinct() 
  <LI>set:leading() 
  <LI>set:trailing() 
  <LI>set:has-same-node() </LI></UL>
<P>Also the following functions in the dates-and-times module: date-time(), 
date(), time(), year(), leap-year(), month-in-year(), month-name(), 
month-abbreviation(), week-in-year(), week-in-month(), day-in-year(), 
day-in-month(), day-of-week-in-month(), day-in-week(), day-abbreviation(), 
hour-in-day(), minute-in-hour(), second-in-minute().</P>
<P>plus the following elements: 
<UL>
  <LI>func:function 
  <LI>func:result </LI></UL>
<P>These have considerable overlap with extension function and elements that 
have previously been provided in the Saxon namespace. The Saxon versions of the 
functions remain available, for the time being, but the EXSLT versions are 
preferred.</P><A name="extension attributes">
<H2>Extension attributes</H2></A>
<P>An extension attribute is an extra attribute on an XSL-defined element. 
Following the rules of XSLT, such attributes must be in a non-default namespace. 
For SAXON extension elements, the namespace must be the SAXON namespace URI 
"http://icl.com/saxon"</P>
<P>For example, the saxon:trace attribute can be set as follows: <PRE><CODE>
&lt;xsl:template match="item" saxon:trace="yes" 
    xmlns:saxon="http://icl.com/saxon"&gt;
</CODE></PRE>
<P>The extension attributes supplied with the SAXON product are as follows:</P>
<TABLE><A name=trace></A>
  <TBODY>
  <TR>
    <TD vAlign=top width="40%"><B>saxon:trace</B></TD>
    <TD>This attribute may be set on the xsl:stylesheet element or the 
      xsl:template element. If set to the value "yes", it causes execution of 
      template rules to be traced to the standard error output. If present on 
      xsl:stylesheet, all template rules are traced; otherwise only selected 
      templates are traced. When present on xsl:stylesheet, it also outputs a 
      list of all the top-level elements in the expanded stylesheet, along with 
      their import precedence.</TD></TR><A name=allow-avt></A>
  <TR>
    <TD vAlign=top width="40%"><B>saxon:allow-avt</B></TD>
    <TD>This attribute may be set on the xsl:call-template element. If set to 
      the value "yes", it causes the name attribute of xsl:call-template to be 
      interpreted as an attribute value template. This allows the selection of 
      the called template to be decided at run-time. Typical usage 
      is:<BR><B>&lt;xsl:call-template name="{$tname}" 
      saxon:allow-avt="yes"&gt;</B></TD></TR><A name=disable></A>
  <TR>
    <TD vAlign=top width="40%"><B>saxon:disable-output-escaping</B></TD>
    <TD>This attribute may be set on the xsl:attribute element. If set to the 
      value "yes", it causes the value of the attribute to be output "as is", 
      without escaping special characters. For example, this allows a URL value 
      to be output containing an unescaped ampersand, e.g. &lt;a 
      href="http://www.acme.com/buy.asp?product=widget&amp;price=12.95"&gt;. 
      This also suppresses the escaping of non-ASCII characters in a URL by %HH 
      sequences.</TD></TR></TBODY></TABLE><A name=output>
<H3>Additional attributes for xsl:output and xsl:document</H3></A>
<P>A number of additional attributes, or attribute values, are allowed on the 
xsl:output and xsl:document elements, beyond those defined in the XSLT 1.1 
specification.</P>
<P>Like the standard attributes of xsl:output and xsl:document, these are all 
interpreted as attribute value templates.</P>
<H4>The method attribute</H4>
<P>The <B>method</B> attribute of xsl:output and xsl:document can take the 
standard values "xml", "html", or "text", or a <I>QName</I>.</P>
<P>If a QName is specified, the local name may be:</P>
<UL>
  <LI>the value "fop", which directs output to Apache's FOP processor (which 
  must be installed separately from www.apache.org) 
  <LI>the value "xhtml", which outputs the result tree in XHTML format. This 
  follows the same rules as method="xml", except that it follows the guidelines 
  for making the XML acceptable to legacy HTML browsers. Specifically (a) empty 
  elements such as &lt;br/&gt; are output as &lt;br/&gt;, and (b) empty elements 
  such as &lt;p/&gt; are output as &lt;p&gt;&lt;/p&gt;. The indent attribute 
  defaults to "yes", and indenting follows the HTML rather than XML rules. Other 
  attributes may be specified as for XML output, e.g. cdata-section-elements and 
  omit-xml-declaration. 
  <LI>the fully-qualified class name of a class that implements either the SAX 
  org.xml.sax.DocumentHandler interface, or the SAX2 org.xml.sax.ContentHandler 
  interface, or that is a subclass of the com.icl.saxon.output.Emitter class. If 
  such a value is specified, output is directed to the user-supplied class. 
</LI></UL>
<P>The prefix of the <I>QName</I> must correspond to a valid namespace URI. It 
is recommended to use the SAXON URI "http://icl.com/saxon", but this is not 
enforced.</P>
<P>Two additional attributes are available on the <B>xsl:output</B> and 
<B>xsl:document</B> elements, for use when <CODE>method="saxon:fop"</CODE>. 
(Note, these are not fully tested).</P>
<UL>
  <LI><B>fop:renderer</B> specifies the name of a FOP Renderer class, for 
  example <CODE>fop:renderer="org.apache.fop.render.pdf.PDFRenderer"</CODE>. 
  <LI><B>fop:configuration</B> specifies the name of a FOP user configuration 
  file, for example <CODE>fop:configuration="c:\config\fop.xml"</CODE> </LI></UL>
<P>Here <B>fop:</B> is the prefix of a namespace whose URI must be 
<CODE>http://icl.com/saxon/fop</CODE></P>
<H4>The saxon:indent-spaces attribute</H4>
<P>When the output is XML or HTML with indent="yes", the saxon:indent-spaces 
attribute may be used to control the amount of indentation. The value must be an 
integer.</P>
<H4>The saxon:character-representation attribute</H4>
<P>This attribute allows greater control over how non-ASCII characters will be 
represented on output.</P>
<P>With method="xml", two values are supported: "decimal" and "hex". These 
control whether numeric character references are output in decimal or 
hexadecimal when the character is not available in the selected encoding. </P>
<P>With HTML, the value may hold two strings, separated by a semicolon. The 
first string defines how non-ASCII characters within the character encoding will 
be represented, the values being "native", "entity", "decimal", or "hex". The 
second string defines how characters outside the encoding will be represented, 
the values being "entity", "decimal", or "hex". Here "native" means output the 
character as itself; "entity" means use a defined entity reference (such as 
"&amp;eacute;") if known; "decimal" and "hex" refer to numeric character 
references. For example "entity;decimal" (the default) means that with 
encoding="iso-8859-1", characters in the range 160-255 will be represented using 
standard HTML entity references, while Unicode characters above 255 will be 
represented as decimal character references.</P>
<H4>The saxon:omit-meta-tag attribute</H4>
<P>This attribute may be set on the xsl:output element when method="html". The 
normal action of the HTML output method, as specified in the XSLT standard, is 
to generate a &lt;META&gt; tag immediately after the &lt;HEAD&gt; tag, 
containing details of the media type and character encoding. Setting this 
attribute to "yes" causes this output to be suppressed. Typical usage is</P>
<P><CODE><B>&lt;xsl:output method="html" saxon:omit-meta-tag="yes"&gt;</B> 
</CODE></P>
<H4>The saxon:next-in-chain attribute</H4>
<P>The <B>saxon:next-in-chain</B> attribute is used to direct the output to 
another stylesheet. The value is the URL of a stylesheet that should be used to 
process the output stream. In this case the output stream must always be pure 
XML, and attributes that control the format of the output (e.g. method, 
cdata-section-elements, etc) will have no effect. The output of the second 
stylesheet will be directed to the destination that would have been used for the 
first stylesheet if no saxon:next-in-chain attribute were present: for 
xsl:output, this means the original transformation result destination; for 
xsl:document, it means the file specified by the href attribute.</P>
<H4>User defined attributes</H4>
<P>Any number of user-defined attributes may be defined on both xsl:output and 
xsl:document. These attributes must have names in a non-null namespace, which 
must not be either the XSLT or the Saxon namespace. These attributes are 
interpreted as attribute value templates. The value of the attribute is inserted 
into the Properties object made available to the Emitter handling the output; 
they will be ignored by the standard output methods, but can supply arbitrary 
information to a user-defined output method. The name of the property will be 
the expanded name of the attribute in JAXP format, for example 
"{http://my-namespace/uri}local-name", and the value will be the value as given, 
after evaluation as an attribute value template.</P>
<HR>
<A name="extension functions">
<H2>Extension functions</H2></A>
<P>A SAXON extension function is invoked using a name such as 
<B>saxon:localname()</B>.</P>
<P>The <B>saxon</B> prefix (or whatever prefix you choose to use) must be 
associated with the SAXON namespace URI "http://icl.com/saxon" or (for backwards 
compatibility) any URI ending with "/com.icl.saxon.functions.Extensions". </P>
<P>For example, to invoke the node-set function, write:</P>
<P><CODE><PRE>&lt;xsl:variable name="fragment"&gt;value&lt;/xsl:variable&gt;
..
&lt;xsl:apply-templates
     select="saxon:node-set($fragment)"
     mode="postprocess"
     xmlns:saxon="http://icl.com/saxon"/&gt;
</PRE></CODE>
<P></P>
<P>The extension functions supplied with the SAXON product are as follows:</P>
<TABLE>
  <TBODY>
  <TR>
    <TD vAlign=top width="40%"><A name=after></A><B>after(node-set-1, 
      node-set-2)</B></TD>
    <TD>This returns a node-set that contains all the nodes in node-set-2 that 
      follow (in document order) at least one node of node-set-2. If node-set-2 
      is empty, the function returns an empty set. This function corresponds to 
      the XQuery AFTER operator and (approximately) to the EXSLT trailing() 
      function.</TD></TR>
  <TR>
    <TD vAlign=top width="40%"><A name=before></A><B>before(node-set-1, 
      node-set-2)</B></TD>
    <TD>This returns a node-set that contains all the nodes in node-set-2 that 
      precede (in document order) at least one node of node-set-2. If node-set-2 
      is empty, the function returns an empty set. This function corresponds to 
      the XQuery BEFORE operator and (approximately) to the EXSLT leading() 
      function.</TD></TR>
  <TR>
    <TD vAlign=top width="40%"><A name=closure></A><B>closure(node-set, 
      expression)</B></TD>
    <TD>This returns a node-set obtained as the transitive closure of applying 
      the given expression to each node in the supplied node-set. For example, 
      saxon:closure(., saxon:expression('*')) returns all the descendant 
      elements of the context node, and saxon:closure(., 
      saxon:expression(id(@idref))) returns all the elements that can be reached 
      by following the @idref attribute treating it as the ID of another 
      element. The function does not detect cycles: if cycles are present in the 
      data, it will recurse indefinitely until it runs out of stack space. To 
      allow expressions such as "*[@father=current()/@name]", each time the 
      expression is evaluated the current node is set to be the same as the 
      context node.</TD></TR>
  <TR>
    <TD vAlign=top width="40%"><A 
      name=difference></A><B>difference(node-set-1, node-set-2)</B></TD>
    <TD>This returns a node-set that is the difference of the two supplied 
      node-sets, that is, it contains all the nodes that are in node-set-1 that 
      are not also in node-set-2. <I>This function is deprecated: use the EXSLT 
      difference() function instead, for portability.</I></TD></TR>
  <TR>
    <TD vAlign=top><A name=distinct></A><B>distinct(node-set-1, 
      [stored-expression])</B></TD>
    <TD>
      <P>This returns a node-set obtained by eliminating nodes in node-set-1 
      that have duplicate values for the supplied stored expression, evaluated 
      as a string. A stored expression may be obtained as the result of calling 
      the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function. If no stored expression is supplied, the default is 
      expression('.'), that is, the string-value of the node. If several nodes 
      produce the same string value, the one that is first in document order 
      will be retained.</P>
      <P>The stored expression is evaluated for each node in node-set-1 in turn, 
      with that node as the context node, with the context position equal to the 
      position of that node in node-set-1, and with the context size equal to 
      the size of node-set-1.</P>
      <P>Example: &lt;xsl:for-each select="saxon:distinct(surname, 
      saxon:expression('substring(.,1,1)')"&gt; will process the first surname 
      starting with each letter of the alphabet in turn.</P>
      <P><I>Note: for the single-argument version, the EXSLT distinct() function 
      should be used in preference, for portability reasons.</I></P></TD></TR>
  <TR>
    <TD vAlign=top><A name=eval></A><B>eval(stored-expression)</B></TD>
    <TD>
      <P>This returns the result of evaluating the supplied stored expression. A 
      stored expression may be obtained as the result of calling the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function.</P>
      <P>The stored expression is evaluated in the current context, that is, the 
      context node is the current node, and the context position and context 
      size are the same as the result of calling position() or last() 
      respectively.
      <P>
      <P>Example: saxon:eval(saxon:expression(concat(2, $op, 2)))</P></TD></TR>
  <TR>
    <TD vAlign=top><A name=evaluate></A><B>evaluate(string)</B></TD>
    <TD>The supplied string must contain an XPath expression. The result of 
      the function is the result of evaluating the XPath expression. This is 
      useful where an expression needs to be constructed at run-time or passed 
      to the stylesheet as a parameter, for example where the sort key is 
      determined dynamically. The context for the expression (e.g. which 
      variables and namespaces are available) is exactly the same as if the 
      expression were written explicitly at this point in the stylesheet. The 
      function saxon:evaluate(string) is shorthand for 
      saxon:eval(saxon:expression(string)).</TD></TR>
  <TR>
    <TD vAlign=top><A name=exists></A><B>exists(node-set-1, 
      stored-expression)</B></TD>
    <TD>
      <P>This returns true if the supplied stored expression evaluates to true 
      for some node in node-set-1, when evaluated as a boolean. Otherwise it 
      returns false. A stored expression may be obtained as the result of 
      calling the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function.</P>
      <P>The stored expression is evaluated for each node in node-set-1 in turn, 
      with that node as the context node, with the context position equal to the 
      position of that node in node-set-1, and with the context size equal to 
      the size of node-set-1.
      <P>
      <P>Example: <B>saxon:exists(sale, saxon:expression('@price * @qty &amp;gt; 
      1000'))</B> will return true if the context node has a child &lt;sale&gt; 
      element for which the product of price and qty exceeds 1000.</P></TD></TR>
  <TR>
    <TD vAlign=top><A name=expression></A><B>expression(string)</B></TD>
    <TD>The supplied string must contain an XPath expression. The result of 
      the function is a <I>stored expression</I>, which may be supplied as an 
      argument to other extension functions such as <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#eval">saxon:eval()</A>, 
      <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#sum">saxon:sum()</A> 
      and <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#sum">saxon:distinct()</A>. 
      The result of the expression will usually depend on the current node. The 
      expression may contain references to variables that are in scope at the 
      point where saxon:expression() is called: these variables will be replaced 
      in the stored expression with the values they take at the time 
      saxon:expression() is called, not the values of the variables at the time 
      the stored expression is evaluated. Similarly, if the expression contains 
      namespace prefixes, these are interpreted in terms of the namespace 
      declarations in scope at the point where the saxon:expression() function 
      is called, not those in scope where the stored expression is 
  evaluated.</TD></TR>
  <TR>
    <TD vAlign=top><A name=forall></A><B>for-all(node-set-1, 
      stored-expression)</B></TD>
    <TD>
      <P>This returns true if the supplied stored expression evaluates to true 
      for every node in node-set-1, when evaluated as a boolean. Otherwise it 
      returns false. A stored expression may be obtained as the result of 
      calling the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function.</P>
      <P>The stored expression is evaluated for each node in node-set-1 in turn, 
      with that node as the context node, with the context position equal to the 
      position of that node in node-set-1, and with the context size equal to 
      the size of node-set-1.
      <P>
      <P>Example: <B>saxon:forAll(sale, saxon:expression('@price * @qty &amp;gt; 
      1000'))</B> will return true if for every child &lt;sale&gt; element of 
      the context node, the product of price and qty exceeds 1000.</P></TD></TR>
  <TR>
    <TD vAlign=top width="40%"><A 
      name=getpseudoattribute></A><B>get-pseudo-attribute(string)</B></TD>
    <TD>This function parses the contents of a processing instruction whose 
      content follows the conventional attribute="value" structure (as defined 
      for the &lt;?xsl-stylesheet?&gt; processing instruction). The context node 
      should be a processing instruction; the function returns the value of the 
      pseudo-attribute named in the first argument if it is present, or an empty 
      string otherwise.</TD></TR>
  <TR>
    <TD vAlign=top width="40%"><A 
      name=getuserdata></A><B>get-user-data(string)</B></TD>
    <TD>This returns user data associated with the context node in the source 
      document. The user data must be set up previously using the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#setuserdata">saxon:setUserData()</A> 
      function.</TD></TR>
  <TR>
    <TD vAlign=top><A name=hassamenodes></A><B>has-same-nodes(node-set-1, 
      node-set-2)</B></TD>
    <TD>This returns a boolean that is true if and only if node-set-1 and 
      node-set-2 contain the same set of nodes. Note this is quite different 
      from the "=" operator, which tests whether there is a pair of nodes with 
      the same string-value.</TD></TR>
  <TR>
    <TD vAlign=top><A name=highest></A><B>highest(node-set-1 [, 
      stored-expression])</B></TD>
    <TD>
      <P>This returns (as a node-set) the node from node-set-1 that has the 
      highest value of the supplied stored expression, evaluated as a number. If 
      the stored expression is omitted, the expression "number(.)" is evaluated: 
      that is, the string value of the node, converted to a number. A stored 
      expression may be obtained as the result of calling the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function.</P>
      <P>The stored expression is evaluated for each node in node-set-1 in turn, 
      with that node as the context node, with the context position equal to the 
      position of that node in node-set-1, and with the context size equal to 
      the size of node-set-1. Any NaN values are ignored. If the node-set is 
      empty, the result is an empty node-set. If several nodes have the highest 
      value, the result node-set contains the one that is first in document 
      order. <I>This differs from the EXSLT highest() function, which returns 
      all the nodes that have the maximum value.</I>
      <P>
      <P>Example: saxon:highest(sale, saxon:expression('@price * @qty')) will 
      evaluate price times quantity for each child &lt;sale&gt; element, and 
      return the node for which this has the highest value.</P></TD></TR>
  <TR>
    <TD vAlign=top><A name=if></A><B>if(condition, value-1, value-2)</B></TD>
    <TD>The first argument is evaluated as a boolean; if it is true, the 
      function returns the value value-1, if it is false, it returns value-2. 
      The value may be of any type. Both the second and third arguments are 
      evaluated even though only one of the values is used.</TD></TR>
  <TR>
    <TD vAlign=top><A name=ifnull></A><B>if-null(java-object)</B></TD>
    <TD>The first argument must be a Java object wrapper returned from an 
      external Java function. The function returns true if the wrapped Java 
      object is null.</TD></TR>
  <TR>
    <TD vAlign=top><A name=intersection></A><B>intersection(node-set-1, 
      node-set-2)</B></TD>
    <TD>This returns a node-set that is the intersection of the two supplied 
      node-sets, that is, it contains all the nodes that are in both sets. Note 
      that the union operation can be done using the built-in operator "|". 
      <I>The intersection() function is deprecated: use the EXSLT intersection() 
      function instead, for portability.</I></TD></TR>
  <TR>
    <TD vAlign=top><A name=leading></A><B>leading(node-set-1, 
      stored-expression)</B></TD>
    <TD>
      <P>This returns a node-set containing all those nodes from node-set-1 up 
      to and excluding the first one (in document order) for which the 
      stored-expression evaluates to false. A stored expression may be obtained 
      as the result of calling the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function.</P>
      <P>The stored expression is evaluated for each node in node-set-1 in turn, 
      with that node as the context node, with the context position equal to the 
      position of that node in node-set-1 (taken in document order), and with 
      the context size equal to the size of node-set-1.
      <P>
      <P>Example: <B>saxon:leading(following-sibling::*, 
      saxon:expression('self::para'))</B> will return the &lt;para&gt; elements 
      following the current node, stopping at the first element that is not a 
      &lt;/;para&gt;</P>
      <P><I>Note: this function is quite different from the EXSLT leading() 
      function, though both fulfil a similar purpose.</I></P></TD></TR>
  <TR>
    <TD vAlign=top><A name=linenumber></A><B>line-number()</B></TD>
    <TD>This returns the line number of the context node in the source 
      document within the entity that contains it. There are no arguments. If 
      line numbers are not maintained for the current document, the function 
      returns -1. (To ensure that line numbers are maintained, use the -l option 
      on the command line)</TD></TR>
  <TR>
    <TD vAlign=top><A name=lowest></A><B>lowest(node-set-1 [, 
      stored-expression])</B></TD>
    <TD>
      <P>This returns (as a node-set) the node from node-set-1 that has the 
      lowest value of the supplied stored expression, evaluated as a number. If 
      the stored expression is omitted, the expression "number(.)" is evaluated: 
      that is, the string value of the node, converted to a number. A stored 
      expression may be obtained as the result of calling the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function.</P>
      <P>The stored expression is evaluated for each node in node-set-1 in turn, 
      with that node as the context node, with the context position equal to the 
      position of that node in node-set-1, and with the context size equal to 
      the size of node-set-1. Any NaN values are ignored. If the node-set is 
      empty, the result is an empty node-set. If several nodes have the lowest 
      value, the result node-set contains the one that is first in document 
      order. <I>This differs from the EXSLT lowest() function, which returns all 
      the nodes that have the minimum value.</I>
      <P>
      <P>Example: saxon:lowest(sale, saxon:expression('@price * @qty')) will 
      evaluate price times quantity for each child &lt;sale&gt; element, and 
      return the node for which this has the lowest value.</P></TD></TR>
  <TR>
    <TD vAlign=top><A name=max></A><B>max(node-set-1 [, 
    stored-expression])</B></TD>
    <TD>
      <P>This returns the maximimum value of a numeric expression resulting from 
      evaluating the supplied stored expression for each node in node-set-1 in 
      turn, as a number. If the stored expression is omitted, the expression 
      "number(.)" is evaluated: that is, the string value of the node, converted 
      to a number. A stored expression may be obtained as the result of calling 
      the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function.</P>
      <P>The stored expression is evaluated for each node in node-set-1 in turn, 
      with that node as the context node, with the context position equal to the 
      position of that node in node-set-1, and with the context size equal to 
      the size of node-set-1. Any NaN values are ignored. If the node-set is 
      empty, the result is negative infinity.
      <P>
      <P><I>For the single-argument version of this function, use the EXSLT 
      max() function instead, for portability.</I></P>
      <P>Example: saxon:max(sale, saxon:expression('@price * @qty')) will 
      evaluate price times quantity for each child &lt;sale&gt; element, and 
      return the maximum amount.</P></TD></TR>
  <TR>
    <TD vAlign=top><A name=min></A><B>min(node-set-1 [, 
    stored-expression])</B></TD>
    <TD>
      <P>This returns the minimum value of a numeric expression resulting from 
      evaluating the supplied stored expression for each node in node-set-1 in 
      turn, as a number. If the stored expression is omitted, the expression 
      "number(.)" is evaluated: that is, the string value of the node, converted 
      to a number. A stored expression may be obtained as the result of calling 
      the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function.</P>
      <P>The stored expression is evaluated for each node in node-set-1 in turn, 
      with that node as the context node, with the context position equal to the 
      position of that node in node-set-1, and with the context size equal to 
      the size of node-set-1. Any NaN values are ignored. If the node-set is 
      empty, the result is positive infinity.
      <P>
      <P><I>For the single-argument version of this function, use the EXSLT 
      min() function instead, for portability.</I></P>
      <P>Example: saxon:min(sale, saxon:expression('@price * @qty')) will 
      evaluate price times quantity for each child &lt;sale&gt; element, and 
      return the minimum amount.</P></TD></TR>
  <TR>
    <TD vAlign=top width="40%"><A 
    name=nodeset></A><B>node-set($fragment)</B></TD>
    <TD><I>When <CODE>version="1.1"</CODE>, a result-tree-fragment is 
      converted implicitly to a node-set if it is used in a context where a 
      node-set is required. However, for portability with other XSLT 1.0 
      processors, it may be better to use the EXSLT node-set() function.</I> The 
      function takes a single argument that is a result tree fragment. Its 
      function is to convert the result tree fragment to a node-set. The 
      resulting node-set contains a single node, which is a root node (class 
      DocumentInfo); below this are the actual nodes added to the result tree 
      fragment, which may be element nodes, text nodes, or anything else. Note 
      that a result tree fragment is not in general a well-formed document, for 
      example there may be multiple element nodes or text nodes as children of 
      the root.</TD></TR>
  <TR>
    <TD vAlign=top width="40%"><A name=path></A><B>path()</B></TD>
    <TD>This takes no arguments. It returns a string whose value is an XPath 
      expression identifying the context node in the source tree. This can be 
      useful for diagnostics, or to create an XPointer value, or when generating 
      another stylesheet to process the same document. The resulting string can 
      be used as input to the evaluate() function, provided that any namespace 
      prefixes it uses are declared.</TD></TR>
  <TR>
    <TD vAlign=top><A name=range></A><B>range(number-1, number-2)</B></TD>
    <TD>The two arguments are converted to numbers and then rounded to 
      integers. A new node-set is constructed containing one node for each 
      integer in the range number-1 to number-2 inclusive; if number-2 is less 
      than number-1 the result will be empty. The string-value of each node will 
      be the relevant number; for example range(2, 5) generates a set of four 
      nodes with string-values "2", "3", "4", and "5". The main intended usage 
      is &lt;xsl:for-each select="range($from, $to)"&gt; which simulates a 
      conventional for loop in other programming languages.</TD></TR>
  <TR>
    <TD vAlign=top width="40%"><A 
      name=setuserdata></A><B>set-user-data(string, value)</B></TD>
    <TD>
      <P>This function sets user data associated with the context node in the 
      source document. The data may be retrieved later (during the same 
      stylesheet execution only) using the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#getuserdata">saxon:get-user-data()</A> 
      function. The string serves as a name for this property, allowing multiple 
      pieces of user data to be associated with the same node. The value may be 
      any XPath value. This function returns an empty string as its nominal 
      result. <B>Note:</B> set-user-data() is particularly useful to save data 
      read during preview mode processing (see <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:preview">saxon:preview</A>) 
      for later use during normal processing. However, take care (a) not to 
      store the data with a node that will be deleted after the preview, and (b) 
      not to store a node-set containing nodes that will be deleted after the 
      preview. It is safest to store simple values such as strings and numbers: 
      use the string() or number() function if necessary to do the 
      conversion.</P>
      <P>Like saxon:assign, this function breaks the XSLT no-side-effects rule. 
      There is always a risk that the Saxon optimizer will execute expressions 
      more than once, or not at all, or in a different order from that 
      expected.</P></TD></TR>
  <TR>
    <TD vAlign=top><A name=sum></A><B>sum(node-set-1, 
stored-expression)</B></TD>
    <TD>
      <P>This returns the total resuling from evaluating the supplied stored 
      expression for each node in node-set-1 in turn, as a number. If the result 
      is NaN for any node, the total will be NaN. A stored expression may be 
      obtained as the result of calling the <A 
      href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#expression">saxon:expression()</A> 
      function.</P>
      <P>The stored expression is evaluated for each node in node-set-1 in turn, 
      with that node as the context node, with the context position equal to the 
      position of that node in node-set-1, and with the context size equal to 
      the size of node-set-1.
      <P>
      <P>Example: saxon:sum(sale, saxon:expression('@price * @qty')) will 
      evaluate price times quantity for each child &lt;sale&gt; element, and 
      return the total amount.</P></TD></TR>
  <TR>
    <TD vAlign=top><A name=systemid></A><B>systemId()</B></TD>
    <TD>This returns the system identifier (URI) of the entity in the source 
      document that contains the context node . There are no arguments.</TD></TR>
  <TR>
    <TD vAlign=top><A name=tokenize></A><B>tokenize(string-1, 
string-2?)</B></TD>
    <TD>The first argument is converted to a string and is treated as a list 
      of separated tokens. If the second argument is present, any character in 
      string-2 is taken as a delimiter character, and any sequence of delimiter 
      characters is taken as a token separator. If the second argument is 
      omitted, any sequence of whitespace is taken as a token separator: or to 
      put it another way, the default for string-2 is 
      '&amp;#x09;&amp;#x0A;&amp;#x0D;&amp;#x20;'.<BR>A new node-set is 
      constructed containing one node for each token; if the string is empty or 
      contains a separator only then the result will be empty. The string-value 
      of each node will be the relevant token; for example tokenize("a cup of 
      tea") generates a set of four nodes with string-values "a", "cup", "of", 
      and "tea". </TD></TR></TBODY></TABLE>
<P></P>
<P>The source code of these methods, which in most cases is extremely simple, 
can be used as an example for writing other user extension functions. It is 
found in class com.icl.saxon.functions.Extensions</P>
<HR>
<A name="Extension elements">
<H2>Extension elements</H2></A>
<P>A SAXON extension element is invoked using a name such as 
<B>&lt;saxon:localname&gt;</B>.</P>
<P>The <B>saxon</B> prefix (or whatever prefix you choose to use) must be 
associated with the SAXON namespace URI "http://icl.com/saxon". The prefix must 
also be designated as an extension element prefix by including it in the 
<B>extension-element-prefixes</B> attribute on the xsl:stylesheet element, or 
the <B>xsl:extension-element-prefixes</B> attribute on any enclosing literal 
result element or extension element.</P>
<P></P>
<P>However, top-level elements such as saxon:handler and saxon:preview can be 
used without designating the prefix as an extension element prefix.</P>
<HR>

<H3><A name=saxon:assign>saxon:assign</A></H3>
<P>The <B>saxon:assign</B> element is used to change the value of a local or 
global variable that has previously been declared using xsl:variable (or 
xsl:param). The variable or parameter must be marked as assignable by including 
the extra attribute saxon:assignable="yes"</P>
<P>As with xsl:variable, the name of the variable is given in the mandatory 
<B>name</B> attribute, and the new value may be given either by an expression in 
the <B>select</B> attribute, or by expanding the content of the saxon:assign 
element</P>
<P>Example:</P>
<TABLE class=code width="100%" border=1>
  <TBODY>
  <TR>
    <TD width="100%" bgColor=#00ffff><FONT face="Courier New" size=3><PRE>&lt;xsl:variable name="i" select="0" saxon:assignable="yes"/&gt;
&lt;saxon:while test="$i &amp;lt; 10"&gt;
    The value of i is &lt;xsl:value-of select="$i"/&gt;
    &lt;saxon:assign name="i" select="$i+1"/&gt;
&lt;/saxon:while&gt;
    </PRE></FONT></TD></TR></TBODY></TABLE>
<HR>

<H3><A name=saxon:doctype>saxon:doctype</A></H3>
<P>The <B>saxon:doctype</B> instruction is used to insert a document type 
declaration into the current output file. It must be instantiated before the 
first element in the output file is written.</P>
<P>The saxon:doctype instruction takes no attributes. The content of the element 
is a template-body that is instantiated to create an XML document that 
represents the DTD to be generated; this XML document is then serialized using a 
special output method that produces DTD syntax rather than XML syntax.</P>
<P>If this element is present the doctype-system and doctype-public attributes 
of xsl:output are ignored</P>
<P>The generated XML document uses the following elements, where the namespace 
prefix "dtd" is used for the namespace URI "http://icl.com/saxon/dtd":</P>
<TABLE>
  <TBODY>
  <TR>
    <TD vAlign=top width="30%">dtd:doctype</TD>
    <TD>Represents the document type declaration. This is always the top-level 
      element. The element may contain dtd:element, dtd:attlist, dtd:entity, and 
      dtd:notation elements. It may have the following 
      attributes:<BR><B>name</B> (mandatory) The name of the document 
      type<BR><B>system</B> The system ID<BR><B>public</B> The public ID </TD></TR>
  <TR>
    <TD vAlign=top width="30%">dtd:element</TD>
    <TD>Represents an element type declaration. This is always a child of 
      dtd:doctype. The element is always empty. It may have the following 
      attributes:<BR><B>name</B> (mandatory) The name of the element 
      type<BR><B>content</B> (mandatory) The content model, exactly as it 
      appears in a DTD, for example content="(#PCDATA)" or content="( a | b | 
      c)*"<BR></TD></TR>
  <TR>
    <TD vAlign=top width="30%">dtd:attlist</TD>
    <TD>Represents an attribute list declaration. This is always a child of 
      dtd:doctype. The element will generally have one or more dtd:attribute 
      children. It may have the following attributes:<BR><B>element</B> 
      (mandatory) The name of the element type<BR></TD></TR>
  <TR>
    <TD vAlign=top width="30%">dtd:attribute</TD>
    <TD>Represents an attribute declaration within an attribute list. This is 
      always a child of dtd:attlist. The element will always be empty. It may 
      have the following attributes:<BR><B>name</B> (mandatory) The name of the 
      attribute<BR><B>type</B> (mandatory) The type of the attribute, exactly as 
      it appears in a DTD, for example type="ID" or type="( red | green | 
      blue)"<BR><B>value</B> (mandatory) The default value of the attribute, 
      exactly as it appears in a DTD, for example value="#REQUIRED" or 
      value="#FIXED 'blue'"<BR></TD></TR>
  <TR>
    <TD vAlign=top width="30%">dtd:entity</TD>
    <TD>Represents an entity declaration. This is always a child of 
      dtd:doctype. The element may be empty, or it may have content. The content 
      is a template body, which is instantiated to define the value of an 
      internal parsed entity. Note that this value includes the delimiting 
      quotes. The xsl:entity element may have the following 
      attributes:<BR><B>name</B> (mandatory) The name of the 
      entity<BR><B>system</B> The system identifier<BR><B>public</B> The public 
      identifier<BR><B>parameter</B> Set to "yes" for a parameter 
      entity<BR><B>notation</B> The name of a notation, for an unparsed 
      entity<BR></TD></TR>
  <TR>
    <TD vAlign=top width="30%">dtd:notation</TD>
    <TD>Represents a notation declaration. This is always a child of 
      dtd:doctype. The element will always be empty. It may have the following 
      attributes:<BR><B>name</B> (mandatory) The name of the 
      notation<BR><B>system</B> The system identifier<BR><B>public</B> The 
      public identifier<BR></TD></TR></TBODY></TABLE>
<P>Note that Saxon will perform only minimal validation on the DTD being 
generated; it will output the components requested but will not check that this 
generates well-formed XML, let alone that the output document instance is valid 
according to this DTD.</P>
<P>Example:</P>
<TABLE class=code width="100%" border=1>
  <TBODY>
  <TR>
    <TD width="100%" bgColor=#00ffff><FONT face="Courier New" size=3><PRE>&lt;xsl:template match="/"&gt;
  &lt;saxon:doctype xsl:extension-element-prefixes="saxon"&gt;
  &lt;dtd:doctype name="booklist"
        xmlns:dtd="http://icl.com/saxon/dtd" xsl:exclude-result-prefixes="dtd"&gt;
    &lt;dtd:element name="booklist" content="(book)*"/&gt;
    &lt;dtd:element name="book" content="EMPTY"/&gt;
    &lt;dtd:attlist element="book"&gt;
      &lt;dtd:attribute name="isbn" type="ID" value="#REQUIRED"/&gt;
      &lt;dtd:attribute name="title" type="CDATA" value="#IMPLIED"/&gt;
    &lt;/dtd:attlist&gt;
    &lt;dtd:entity name="blurb"&gt;'A &lt;i&gt;cool&lt;/i&gt; book with &amp;gt; 200 pictures!'&lt;/dtd:entity&gt;
    &lt;dtd:entity name="cover" system="cover.gif" notation="GIF"/&gt;
    &lt;dtd:notation name="GIF" system="http://gif.org/"/&gt;
  &lt;/dtd:doctype&gt;
  &lt;/saxon:doctype&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</PRE></FONT></TD></TR></TBODY></TABLE>
<P>Although not shown in this example, there is nothing to stop the DTD being 
generated as the output of a transformation, using instructions such as 
xsl:value-of and xsl:call-template. It is also possible to use xsl:text with 
disable-output-escaping="yes" to output DTD constructs not covered by this 
syntax, for example conditional sections and references to parameter 
entities.</P>
<HR>

<H3><A name=saxon:entity-ref>saxon:entity-ref</A></H3>
<P>The saxon:entity-ref element is useful to generate entities such as 
&amp;nbsp; in HTML output. To do this, write:</P>
<P>
<TABLE class=code width="100%" border=1>
  <TBODY>
  <TR>
    <TD width="100%" bgColor=#00ffff><FONT face="Courier New" size=3><PRE>        &lt;saxon:entity-ref name="nbsp"/&gt;
</PRE></FONT></TD></TR></TBODY></TABLE></P>
<HR>

<H3><A name=saxon:function>saxon:function</A></H3>
<P>The <B>saxon:function</B> element is used to declare an extension function 
implemented in the XSLT language. <I>The effect is identical to the 
func:function element defined in EXSLT, and the EXSLT version should be used in 
preference, for portability.</I></P>
<P>This is a top-level element; its content is a template-body, optionally 
preceded by one or more xsl:param elements.</P>
<P>There must be a <B>name</B> attribute; its value is a QName, and it must have 
a non-null namespace URI.</P>
<P>The function definition will normally contain one or more <A 
href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:return">saxon:return</A> 
instructions to define the return value; if the function exits without 
encountering a saxon:return, the result is an empty string. It is an error if 
more than one saxon:return instruction is instantiated (remember that the 
execution model is not sequential, so saxon:return does not cause an immediate 
exit - it merely defines the return value.).</P>
<P>The parameters are interpreted positionally. If there are more parameters 
declared using xsl:param than are supplied in the function call, the excess 
parameters take their default values. It is an error to have more arguments in 
the function call than there are parameters declared in the function body.</P>
<P>In a function call where the function name has a non-null namespace URI, the 
system searches first for a matching saxon:function definition, then for an 
external Java function. If there are several functions with the same name, the 
one with highest import precedence is chosen; if there are several of these, the 
one that appears last in the stylesheet wins.</P>
<P>Calling a function does not change the current node or the values of 
position() and last().</P>
<P>A function body may contain local variables in the same way as a template 
body.</P>
<P>Functions provide an alternative to named templates. The main differences are 
that the syntax for calling them is simpler (it is a standard XPath function 
call) and that they can return a value of any type.</P>
<P>A function is not allowed to write anything to the result tree. More 
precisely, it is not allowed to write to the current output destination of the 
code that calls it. It is, however, allowed to create a new result tree fragment 
within the code of the function, or a new xsl:document destination, and write to 
this. The reason for this restriction is that it is generally unpredictable when 
and how often a function will be called, especially if it is used inside a 
predicate, so it is safest for it to have no side-effects.</P>
<P>One particular use for XSLT extension functions is to provide wrappers for 
Java extension functions, making them more convenient to call from XPath 
expressions. Another use is in contexts where named templates cannot be called, 
for example in the expressions used to define a named key (xsl:key) or a sort 
key (xsl:sort), or in the predicate of a match pattern.</P>
<P>The <B>saxon:function</B> element automatically declares the Saxon namespace 
as an extension namespace, so that <B>saxon:return</B> is recognized.</P>
<P>Example:</P>
<TABLE class=code width="100%" border=1>
  <TBODY>
  <TR>
    <TD width="100%" bgColor=#00ffff><FONT face="Courier New" size=3><PRE>&lt;saxon:function name="my:initial"&gt;
    &lt;xsl:param name="size"/&gt;
    &lt;saxon:return select="substring(.,1,$size)"/&gt;
&lt;/saxon:function&gt;

&lt;xsl:template match="text()"&gt;
    &lt;xsl:value-of select="my:initial(3)"/&gt;
&lt;/xsl:template&gt;

</PRE></FONT></TD></TR></TBODY></TABLE>
<HR>

<H3><A name=saxon:group>saxon:group</A></H3>
<P>The <B>&lt;saxon:group&gt;</B> element causes iteration over the nodes 
selected by a node-set expression.</P>
<P>There is a mandatory attribute, <B>select</B>, which defines the nodes over 
which the statement will iterate. This is analogous to the select attribute of 
&lt;xsl:for-each&gt;</P>
<P>There is also a mandatory <B>group-by</B> attribute to control grouping. The 
value of this attribute is a string expression, which is applied to each item 
selected by the <B>select</B> expression. The XSL statements subordinate to the 
&lt;saxon:group&gt; element are applied once to each group of consecutive source 
nodes selected by the select expression that have the same value for the 
group-by expression.
<P>
<P>The &lt;saxon:group&gt; element may have one or more <B>&lt;xsl:sort&gt;</B> 
child elements to define the order of sorting. The sort keys are specified in 
major-to-minor order. Note that group-by does not itself cause sorting, but it 
can conveniently be used in conjunction with sorting. The group-by key will 
often be the same as the major sort key.</P>
<P>The &lt;saxon:group&gt; element must contain somewhere within it an 
&lt;saxon:item&gt; element. The XSL instructions outside the &lt;saxon:item&gt; 
element are executed only once for each group of consecutive elements with the 
same value for the grouping key; the instructions within the saxon:item are 
executed once for each individual item in the saxon:group selection. </P>
<P>The context for the select expression is the usual context for expressions 
within an XSL element, i.e. it is based on the current node and current node 
list of the containing template body.</B> 
<P>The context for the group-by expression is as if the expression were written 
inside the saxon:group loop. If the select expression selects a node-set S, then 
for each node N within S, the group-by expression is evaluated with N as the 
context node, with count(S) as the context size, and with the context position 
taking the values 1..count(S) in turn. The context position represents the 
position of the node in the node-set <I>after sorting</I>.</P>
<P>If there is an &lt;xsl:sort&gt; element present, then the context for 
evaluating the sort key follows exactly the same rules as for 
&lt;xsl:for-each&gt;. In particular, the context position is the position 
<I>before sorting</I>.</P>
<P>Within the &lt;saxon:group&gt; element, and also within the 
&lt;saxon:item&gt;; element, the context reflects the full node-set being 
processed (that is, the node-set selected by the select attribute). The context 
position is the position of the node within this node-set, and the context size 
is the size of this node-set. It is not possible to determine the size of an 
individual group, or the position of the current node within an individual 
group. The instructions preceding &lt;saxon:item&gt; are executed with the first 
node of a group as the current node, and the instructions following 
&lt;saxon:item&gt; are executed with the last node of a group as the current 
node.</P>
<P>The expressions used for sorting and grouping can be any string expressions. 
The following are particularly useful:</P>
<UL>
  <LI>element-name, e.g. TITLE: sorts or groups on the value of a child element 
  <LI>attribute-name, e.g. @CODE: sorts or groups on the value of an attribute 
  <LI>".": sorts or groups on the character content of the element 
  <LI>"name(.)": sorts or groups on the name of the element </LI></UL>
<P>Example: This example groups the BOOK elements having the same AUTHOR.</P>
<TABLE class=code width="100%" border=1>
  <TBODY>
  <TR>
    <TD width="100%" bgColor=#00ffff><FONT face="Courier New" size=3><XMP><xsl:template match="BOOKLIST">
    <h2>
        <saxon:group select="BOOK" group-by="AUTHOR">
            <xsl:sort select="AUTHOR"/>
            <h3>AUTHOR: <xsl:value-of select="AUTHOR"></h3>
            <saxon:item>
                <p>TITLE: <xsl:value-of select="TITLE"/></p>
            </saxon:item>
            <hr/>
        </saxon:group>          
    </h2>
</xsl:template></XMP></FONT></TD></TR></TBODY></TABLE>
<DIV></DIV><FONT size=2>
<HR>

<H3><A name=saxon:handler>saxon:handler</A></H3>
<P>The saxon:handler element is used at the top level of the stylesheet, in the 
same way as xsl:template. It takes attributes match, mode, name, and priority in 
the same way as xsl:template, and is considered along with all XSL templates 
when searching for a template to execute in response to xsl:apply-templates or 
xsl:call-template. However, the action performed when a saxon:handler is invoked 
is to call the user-written Java NodeHandler named in the mandatory 
<B>handler</B> attribute.</P>
<P>The Java node handler must be written as a subclass of 
com.icl.saxon.handlers.NodeHandler. It is supplied with a Context parameter, 
which gives access to a wide range of information and services, including the 
current context in the source document, any parameters on the call, and the 
Outputter object used to write to the result tree. The Context parameter also 
provides access to a method applyTemplates() which allows the Java node handler 
to make a call back to process XSLT templates in the stylesheet.</P>
<HR>

<H3><A name=saxon:item>saxon:item</A></H3>
<P>The <B>saxon:item</B> element is always used within a <B>saxon:group</B> 
element. The XSL instructions outside the saxon:item element are executed once 
for each group (that is, each group of consecutive items with the same value for 
the group-by expression), while the XSL instructions within the saxon:item 
element are executed once for each individual item.</P>
<P>See <A 
href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#saxon:group">saxon:group</A> 
for further details.</P>
<HR>

<H3><A name=saxon:output>saxon:output</A></H3>
<P>The <B>saxon:output</B> instruction is a synonym for <A 
href="http://saxon.sourceforge.net/saxon6.5.1/xsl-elements#xsl:document">xsl:document</A>, 
introduced in the working draft of XSLT 1.1. While <CODE>xsl:document</CODE> is 
available only when <CODE>version="1.1"</CODE>, <CODE>saxon:output</CODE> is 
always available, provided the relevant namespace is declared as an extension 
namespace. The attributes are identical to those of 
<CODE>xsl:document</CODE>.</P>
<HR>

<H3><A name=saxon:preview>saxon:preview</A></H3>
<P>The <B>saxon:preview</B> element is a top-level element used to identify 
elements in the source document that will be processed in <I>preview</I> mode. 
The purpose of preview mode is to enable XSLT processing of very large documents 
that are too big to fit in memory: the idea is that subtrees of the document can 
be processed and then discarded as soon as they are encountered.</P>
<P>There are two mandatory attributes: <B>mode</B> identifies the mode in which 
the relevant templates will be applied, and <B>elements</B> is a space-separated 
list of element names that will be processed in preview mode.</P>
<P>While the source XML document is being read, if an element end tag is 
encountered for an element that is in the list of preview elements, the relevant 
template is found (using the normal matching rules, with mode equal to the 
specified preview mode). This template is then executed. After the template has 
completed execution, the child nodes of the preview element (but not the element 
itself, nor its attributes) are deleted from the tree to save memory.</P>
<P>During the matching of a preview element and during the execution of the 
preview template, only part of the source document is visible. This part 
includes the ancestors of the preview element, the descendants of the preview 
element, and all nodes that precede the preview element in document order, 
except for nodes that are descendants of another preview element.</P>
<P>Global variables are not available to a preview template. The supplied values 
of global parameters are available, but not the default values of unsupplied 
parameters.</P>
<P>A preview template may write to a secondary output destination using 
saxon:output, or it may set global variables using saxon:assign. It can save 
information using the extension function <A 
href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#setuserdata">setUserData()</A>, 
which can be accessed later using <A 
href="http://saxon.sourceforge.net/saxon6.5.1/extensions.html#getuserdata">getUserData()</A>. 
This is useful to save information that would otherwise disappear when the 
subtree rooted at the preview element is deleted from the tree. The preview 
template may also write directly to the principal output destination, but note 
that in this case each instantiation of the preview template will produce a 
subtree immediately below the root of the output tree. Normally this means the 
output document will have multiple element nodes as children of the root. This 
is not well-formed XML, but you can easily construct a well-formed XML document 
by referencing this file as an external entity.</P>
<P>One simple use for saxon:preview is simply to delete unwanted parts of the 
tree to reduce the amount of memory needed. In this case, just provide a preview 
template that does nothing.</P>
<P>Preview templates are called while the tree is being built. When the tree has 
been completely built, it will contain the preview elements themselves, but any 
nodes that were descendants of the preview elements will have been deleted. At 
this stage the stylesheet is applied to the root of the tree, in "default" mode, 
in the normal way. If you don't want any further processing to take place at 
this stage, write a root template that does nothing: &lt;xsl:template 
match="/"/&gt;.</P>
<P>&lt;saxon:preview&gt; is not supported when a transformation is run using the 
JAXP 1.1 TransformerHandler interface. It works when using the Saxon command 
line, or when invoking a transformation using the transform() method.</P>
<HR>

<H3><A name=saxon:return>saxon:return</A></H3>
<P>The <B>saxon:return</B> element is an instruction that can only occur within 
a saxon:function definition. It must not have any following sibling instructions 
other than xsl:fallback. However, there can be more than one saxon:return 
instruction in a function, for example one in each branch of an xsl:choose. 
<I>The saxon:return instruction is a synonym of the EXSLT func:result 
instruction: the EXSLT version is preferred, for portability reasons.</I></P>
<P>Instantiating a saxon:return element causes exit from the call of the 
enclosing saxon:function.</P>
<P>The saxon:return element has an optional <B>select</B> attribute, whose value 
is an XPath expression. If the select attribute is present, this expression is 
evaluated and its value constitutes the return value of the function. If it is 
absent, the content of the saxon:return element is instantiated and the result 
is returned as a result tree fragment. If the element is empty and has no select 
attribute, the function returns an empty string.</P>
<P>If a function completes without instantiating a saxon:return instruction, the 
return value of the function is an empty string. It is an error for a function 
to instantiate more than one saxon:return instruction.</P>
<HR>

<H3><A name=saxon:script>saxon:script</A></H3>
<P>The <B>saxon:script</B> element is a top-level element. It is a synonym of <A 
href="http://saxon.sourceforge.net/saxon6.5.1/xsl-elements#xsl:script">xsl:script</A>, 
except that it is available regardless of the setting of the 
<CODE>version</CODE> attribute on <CODE>xsl:stylesheet</CODE>.</P>
<P>The reason for providing saxon:script as a separate element is that any 
processor other than Saxon will ignore it. This makes it possible to define an 
implementation for an extension function that will be used by Saxon, but not by 
other processors. With other processors, a different implementation can be 
selected, using mechanisms defined by that processor (for example, 
xalan:script).</P>
<P>If you want to use extension functions such as xx:intersection() which are 
available as built-in extensions in several XSLT processors, you can define the 
Saxon implementation as follows:</P>
<TABLE class=code width="100%" border=1>
  <TBODY>
  <TR>
    <TD width="100%" bgColor=#00ffff><FONT face="Courier New" size=3><XMP><saxon:script implements-prefix="xx" language="java" 
              src="java:com.icl.saxon.functions.Extensions">
</XMP></FONT></TD></TR></TBODY></TABLE>
<DIV></DIV>
<HR>

<H3><A name=saxon:while>saxon:while</A></H3>
<P>The <B>saxon:while</B> element is used to iterate while some condition is 
true.</P>
<P>The condition is given as a boolean expression in the mandatory test 
attribute. Because this expression must change its value if the loop is to 
terminate, the condition will always reference a variable that is updated 
somewhere in the loop using an saxon:assign element.</P>
<P>Example:</P>
<TABLE class=code width="100%" border=1>
  <TBODY>
  <TR>
    <TD width="100%" bgColor=#00ffff><FONT face="Courier New" size=3><PRE>&lt;xsl:variable name="i" expr="0"/&gt;
&lt;saxon:while test="$i &amp;lt; 10"&gt;
    The value of i is &lt;xsl:value-of select="$i"/&gt;
    &lt;saxon:assign name="i" expr="$i+1"/&gt;
&lt;/saxon:while&gt;
    </PRE></FONT></TD></TR></TBODY></TABLE>
<HR>

<P align=center><A href="mailto:michael.h.kay@ntlworld.com">Michael H. Kay</A> 
<BR>14 November 2001 </P></FONT></FONT></FONT></BODY></HTML>
